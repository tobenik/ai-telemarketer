from flask import Flask, request, url_for
from twilio.twiml.voice_response import VoiceResponse, Gather
import os
from dotenv import load_dotenv
from logger import setup_logger
from middleware.logging_middleware import setup_logging_middleware
from playbooks.me_naiset import ME_NAISET_PLAYBOOK
from llm.client import LLMClient
from tts.elevenlabs_client import ElevenLabsClient
from flask import send_file

load_dotenv()

# Setup separate loggers for different concerns
server_logger = setup_logger('server', 'server.log')

app = Flask(__name__)
NGROK_URL = os.getenv('NGROK_URL')

# Setup logging middleware
setup_logging_middleware(app, server_logger)

# Initialize clients
llm_client = LLMClient(playbook=ME_NAISET_PLAYBOOK)
tts_client = ElevenLabsClient()

# Store audio files temporarily
audio_cache = {}

@app.route("/")
def home():
    return "Pong!"

@app.route("/answer", methods=['GET', 'POST'])
def answer_call():
    # Get user input if available (for follow-up calls)
    user_input = request.values.get('SpeechResult', '')
    server_logger.info(f"Received call with input: '{user_input}'")
    
    # Get response from LLM
    llm_response = llm_client.get_response(user_input)
    
    # Convert text to speech using ElevenLabs
    audio_path = tts_client.text_to_speech(llm_response)
    
    # Create a unique identifier for this audio file
    audio_id = os.path.basename(audio_path)
    audio_cache[audio_id] = audio_path
    
    # Create Twilio response
    response = VoiceResponse()
    
    # Play the audio file from ElevenLabs
    if audio_path:
        audio_url = f"{NGROK_URL}/audio/{audio_id}"
        response.play(audio_url)
    else:
        # Fallback to Twilio's say if ElevenLabs fails
        response.say(llm_response, voice="Polly.Amy", language="fi-FI")
    
    # Set up for user response
    gather = Gather(input='speech', 
                   action='/continue',
                   language='fi-FI',
                   speechTimeout='auto')
    response.append(gather)
    
    # If user doesn't say anything, wait and then end the call
    response.redirect('/end_call')
    server_logger.info(f"Response sent to caller: '{llm_response}'")
    return str(response)

@app.route("/audio/<audio_id>", methods=['GET'])
def serve_audio(audio_id):
    """Serve audio files generated by ElevenLabs"""
    if audio_id in audio_cache:
        server_logger.info(f"Serving audio file: {audio_id}")
        return send_file(audio_cache[audio_id], mimetype='audio/mpeg')
    else:
        server_logger.error(f"Audio file not found: {audio_id}")
        return "Audio not found", 404

@app.route("/continue", methods=['POST'])
def continue_conversation():
    server_logger.info("Continuing conversation...")
    return answer_call()

@app.route("/end_call", methods=['POST'])
def end_call():
    server_logger.info("Call ending - no user input detected")
    response = VoiceResponse()
    
    # Get goodbye message
    goodbye_message = "Kiitos ajastasi. NÃ¤kemiin!"
    
    # Convert goodbye to speech using ElevenLabs
    audio_path = tts_client.text_to_speech(goodbye_message)
    
    if audio_path:
        # Create a unique identifier for this audio file
        audio_id = os.path.basename(audio_path)
        audio_cache[audio_id] = audio_path
        
        audio_url = f"{NGROK_URL}/audio/{audio_id}"
        response.play(audio_url)
    else:
        # Fallback to Twilio's say if ElevenLabs fails
        response.say(goodbye_message, voice="Polly.Amy", language="fi-FI")
        
    response.hangup()
    return str(response)

# Add a cleanup route to manage temporary files
@app.route("/cleanup", methods=['POST'])
def cleanup_audio_files():
    """Clean up temporary audio files"""
    count = 0
    for audio_id, path in list(audio_cache.items()):
        try:
            os.remove(path)
            del audio_cache[audio_id]
            count += 1
        except Exception as e:
            server_logger.error(f"Error cleaning up {audio_id}: {str(e)}")
    
    server_logger.info(f"Cleaned up {count} audio files")
    return f"Cleaned up {count} audio files", 200

if __name__ == "__main__":
    server_logger.info("Starting AI Telemarketer server...")
    app.run(debug=True, port=5001)